# A0142325R
###### /java/guitests/AddCommandTest.java
``` java

/**
 * test for add command in gui
 * @author LiXiaowei
 *
 */

public class AddCommandTest extends TaskManagerGuiTest {
    
    TestTask[] currentList;
    TestTask taskToAdd;
    
    @Before
    public void setUpLists(){
        currentList=td.getTypicalTasks();
    }
    
    //------------------------------valid cases---------------------------------------------
    
    //add an event to list
    
    @Test
    public void add_eventToList_success(){
        
        taskToAdd = td.project;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        int taskIndex = currentList.length;
        assertItemSelected(taskIndex);
    }
    
    //add a task to list
    
    @Test
    public void add_taskToList_success(){
        taskToAdd = td.workshop;
        assertAddSuccess(taskToAdd, currentList);
        
        int taskIndex = currentList.length + 1;
        assertItemSelected(taskIndex);
    }
    
    //add item to an empty list
    
    @Test
    public void add_toEmptyList_success(){
        commandBox.runCommand("clear");
        assertAddSuccess(td.friend);
        
        int taskIndex = 1;
        assertItemSelected(taskIndex);
    }
    
    //use flexi add command
    
    @Test
    public void add_flexiCommandFormat_success(){
        
        taskToAdd = td.project;
        assertFlexiAddSuccess(taskToAdd, currentList);
        
        int taskIndex = currentList.length + 1;
        assertItemSelected(taskIndex);
    }
    
    //-----------------------------invalid cases--------------------------------------------
    
    //invalid command
    
    @Test
    public void add_invalidArgsFormat_fail(){
        
        commandBox.runCommand("adds Johnny");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }
    
    
    /**
     * assert add success for general addCommand with correct argument order
     * @param personToAdd
     * @param currentList
     */


    private void assertAddSuccess(TestTask personToAdd, TestTask... currentList) {
        commandBox.runCommand(personToAdd.getAddCommand());

        // confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(personToAdd.getName().taskName);
        assertMatching(personToAdd, addedCard);

        // confirm the list now contains all previous persons plus the new
        // person
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, personToAdd);
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    /**
     * assert add success for flexi add command with arguments in any random order
     * @param personToAdd
     * @param currentList
     */

    private void assertFlexiAddSuccess(TestTask personToAdd, TestTask... currentList) {
        commandBox.runCommand(personToAdd.getFlexiAddCommand());

        // confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(personToAdd.getName().taskName);
        assertMatching(personToAdd, addedCard);

        // confirm the list now contains all previous persons plus the new
        // person
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, personToAdd);
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    private void assertItemSelected(int index) {
        assertEquals(taskListPanel.getSelectedTasks().size(), 1);
        ReadOnlyTask selectedTask = taskListPanel.getSelectedTasks().get(0);
        assertEquals(taskListPanel.getTask(index-1), selectedTask);
    }

}
```
###### /java/guitests/DeleteCommandTest.java
``` java

/**
 * test for delete command on gui
 * @author LiXiaowei
 * 
 * use cases: 1) delete by index 2) delete by name
 *  
 */
public class DeleteCommandTest extends TaskManagerGuiTest {
    
    //----------------------------------valid cases-----------------------------------------
    
    //test for use scenario 1: delete by index

    @Test
    public void delete_byIndex_success() {

        //delete the first in the list
        TestTask[] currentList = td.getTypicalTasks();

        int targetIndex = 1;
        assertDeleteSuccess(targetIndex, currentList);

        //delete the last in the list

        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = currentList.length;

        assertDeleteSuccess(targetIndex, currentList);

        //delete from the middle of the list
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = currentList.length/2;
        assertDeleteSuccess(targetIndex, currentList);

    }
    
    //test for use scenario 2: delete by name
    
    @Test
    public void delete_byName_success(){
    	TestTask[] currentList=td.getTypicalTasks();
    	
    	//delete task with an unique name
    	assertDeleteSuccess("Read book",currentList);
    	
    	//delete task duplicated name
    	assertDeleteSuccess("Meet old friends",currentList);
    	
    }
    
    //test for invalid index entered
    
    @Test
    public void delete_byInvalidIndex_fail(){
        TestTask[] currentList=td.getTypicalTasks();
        commandBox.runCommand("delete " + currentList.length + 1);
        assertResultMessage("The index provided is invalid");
    }
    
    //------------------------------------invalid cases----------------------------------
    
    //test for delete task or event name that does not exist
    
    @Test
    public void delete_byNonExistantName_fail(){
        commandBox.runCommand("delete bason");
        assertResultMessage(DeleteCommand.MESSAGE_DELETE_NOT_FOUND);
    }

    /**
     * Runs the delete command to delete the task or event at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first task in the list, 1 should be given as the target index.
     * @param currentList A copy of the current list of tasks (before deletion).
     */   
    private void assertDeleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("delete " + targetIndexOneIndexed);

        //confirm the list now contains all previous persons except the deleted person
        assertTrue(taskListPanel.isListMatching(expectedRemainder));
    }
    
    
    /**
     * Runs the delete command to delete the item of specific name. A list of possible tasks
     * or events with one or more of the input parameters will be shown.
     * @param taskName
     * @param currentList
     */ 
    private void assertDeleteSuccess(String taskName,final TestTask[] currentList){
    	ArrayList<TestTask> tasksToDelete=new ArrayList<TestTask>();
    	for(TestTask e:currentList){
    		if(taskName.equals(e.getName().taskName))
    			tasksToDelete.add(e);
    	}
    	
    	if(tasksToDelete.size()==0){
    		commandBox.runCommand("delete "+taskName);
    		assertResultMessage(String.format(MESSAGE_INVALID_TASK_NAME));
    	}
    	else{
    		commandBox.runCommand("delete "+taskName);
    		assertResultMessage(String.format(MESSAGE_DELETE_SAME_NAME));
    	}
   
    }

}
```
###### /java/guitests/DoneCommandTest.java
``` java

/**
 * test for done command execution on gui
 * @author LiXiaowei
 * 
 * use scenarios: 1) mark a task as done by index as the last shown list
 *                2) mark a task as done by name
 *
 */
public class DoneCommandTest extends TaskManagerGuiTest {
    
    TestTask[] currentList;
    
    @Before
    public void setUpLists(){
        currentList=td.getTypicalTasks();
    }
    
    //---------------------------------valid cases--------------------------------------------

    //test for scenario1: mark done by index
    
    @Test
    public void markDone_byIndex_success() {
        
        currentList[0].markAsDone();
        assertDoneSuccess("done 1", currentList);
        
    }
    
    //test for scenario 2: mark done by name
    
    @Test
    public void markDone_byName_success(){
        
        // Mark task as done by name
        currentList[4].markAsDone();
        commandBox.runCommand("done Work");
        assertResultMessage(DoneCommand.MULTIPLE_TASK_SATISFY_KEYWORD);
        assertDoneSuccess("done 1", currentList);
        
        // Mark task as done by name with multiple satisfied
        currentList[2].markAsDone();
        commandBox.runCommand("done friends");
        assertResultMessage(DoneCommand.MULTIPLE_TASK_SATISFY_KEYWORD);
        assertDoneSuccess("done 3", currentList);
        
        
    }
    
    //-------------------------------------invalid cases---------------------------------------
    
    //test for invalid index
    
    @Test
    public void markDone_byInvalidIndex_fail(){
        commandBox.runCommand("done 12");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        
    }
    
    //test for nonexistent name
    
    @Test
    public void markDone_byNonExistantName_fail(){
        
        commandBox.runCommand("done dinner");
        assertResultMessage(DoneCommand.TASK_NOT_FOUND);
    }

    private void assertDoneSuccess(String command, TestTask... currentList) {
        commandBox.runCommand(command);
        assertTrue(taskListPanel.isListMatching(currentList));
    }

}
```
###### /java/guitests/FindCommandTest.java
``` java
public class FindCommandTest extends TaskManagerGuiTest {

    @Test
    public void find_nonEmptyList_success() {
        assertFindResult("find Mark"); // no results
        assertFindResult("find friends", td.friend, td.friendEvent, td.lunch); // multiple results

        // find after deleting one result
        commandBox.runCommand("delete 1");
        assertFindResult("find friends", td.friendEvent, td.lunch);
    }

    @Test
    public void find_emptyList_success() {
        commandBox.runCommand("clear");
        assertFindResult("find project"); // no results
    }

    @Test
    public void find_invalidCommand_fail() {
        commandBox.runCommand("findgeorge");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

```
###### /java/guitests/FindCommandTest.java
``` java
    private void assertFindResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertResultMessage(expectedHits.length + " events and tasks listed!");
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### /java/guitests/ListCommandTest.java
``` java

/**
 * Test GUI for list command
 * @author LiXiaowei
 * Command format: list, list tasks/events/done/undone
 * 
 * Equivalence partitions: emply parameter, tasks, events, done, undone, otherInvalidData
 *
 */
public class ListCommandTest extends TaskManagerGuiTest {
    private TestTask[] currentList;
    
    @Before
    public void setUpLists(){
        currentList=td.getTypicalTasks();
    }
    
    //----------------------------valid cases-----------------------------------------------
    
    //list all tasks

    @Test
    public void list_allTasks_successful(){
        assertListResult("list tasks",td.friend,td.friendEvent,td.lunch,
                td.book,td.work,td.movie);
        assertResultMessage(String.format(ListCommand.MESSAGE_TASK_SUCCESS));
        
    }
    
    //list all events
    
    @Test
    public void list_allEvents_successful(){
        assertListResult("list events", td.meeting,td.travel);
        assertResultMessage(String.format(ListCommand.MESSAGE_EVENT_SUCCESS));
        
    }
    
    //list all tasks and events
    
    @Test
    public void list_allTasksAndEvents_successful(){
        assertListResult("list",currentList);
        assertResultMessage(String.format(ListCommand.MESSAGE_SUCCESS));
        
        
    }
    
    //list all done items
    
    @Test
    public void list_allDoneTasksAndEvents_successful(){
        commandBox.runCommand("done 1");
        td.friend.markAsDone();
        assertListResult("list done", td.friend);
        assertResultMessage(String.format(ListCommand.MESSAGE_LIST_DONE_TASK_SUCCESS));
        
    }
    
    //list all undone items
    
    @Test
    public void list_allUndoneTasksAndEvents_successful(){
        
        assertListResult("list undone", td.friend,td.friendEvent, td.lunch, td.book, td.work, td.movie, td.meeting, td.travel);
        assertResultMessage(String.format(ListCommand.MESSAGE_LIST_UNDONE_TASK_SUCCESS));
    }
    
    //list empty list
    
    @Test
    public void list_emptyLists_successful(){
        commandBox.runCommand("clear");
        assertListResult("list");
        
        
    }
    
    //----------------------------invalid cases-------------------------------------------
    
    //invalid command
    
    @Test
    public void list_invalidDataField_fail(){
        commandBox.runCommand("lists");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
        commandBox.runCommand("list unknown");
        assertResultMessage(ListCommand.MESSAGE_INVALID_LIST_COMMAND);
        
        
    }
   
    private void assertListResult(String command, TestTask... expectedHits ) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }

}
```
###### /java/guitests/RefreshCommandTest.java
``` java

/**
 * test for refresh command on gui
 * 
 * @author LiXiaowei
 *
 */
public class RefreshCommandTest extends TaskManagerGuiTest {

    // -------------------------------------valid cases----------------------------------------

    // test for valid cases
    
    /*
     * Equivalence partitions for itemType:
     *  - refresh out-dated recurring deadlineTask
     *  - refresh out-dated recurring event
     *  
     *  Equivalence partitions for recurring frequency:
     *  - monthly
     *  - weekly
     *  - daily
     */
    
    @Test
    public void refresh_allTasksAndEvents_success() {

        TestTask[] currentList = td.getTypicalTasks();
        // refresh all non-recurring tasks
        assertRefreshResult("refresh", td.friend, td.friendEvent, td.lunch, td.book, td.work, td.movie, td.meeting,
                td.travel);
        assertResultMessage(String.format(RefreshCommand.MESSAGE_SUCCESS));

    }

    // refresh all tasks including one recurring event (recurring weekly)
    @Test
    public void refresh_recurringDeadlineTaskWeekly_success() {
        TestTask taskToAdd = td.lecture;
        commandBox.runCommand(taskToAdd.getAddCommand());

        assertRefreshResult("refresh", td.friend, td.friendEvent, td.lunch, td.book, td.work, td.movie, td.meeting,
                td.travel, td.lectureVerifier);
        assertResultMessage(String.format(RefreshCommand.MESSAGE_SUCCESS));
    }

    // refresh all tasks including one recurring deadlineTask (recurring daily)
    @Test
    public void refresh_recurringEventDaily_success() {
        TestTask taskToAdd = td.swimming;
        commandBox.runCommand(taskToAdd.getAddCommand());

        assertRefreshResult("refresh", td.friend, td.friendEvent, td.lunch, td.book, td.work, td.movie, td.meeting,
                td.travel, td.swimmingVerifier);
        assertResultMessage(String.format(RefreshCommand.MESSAGE_SUCCESS));
    }

    // refresh all tasks including one recurring deadlineTask (recurring monthly)
    @Test
    public void refresh_recurringDeadlineTaskMonthly_success() {
        TestTask taskToAdd = td.teaching;
        commandBox.runCommand(taskToAdd.getAddCommand());

        assertRefreshResult("refresh", td.friend, td.friendEvent, td.lunch, td.book, td.work, td.movie, td.meeting,
                td.travel, td.teachingVerifier);
        assertResultMessage(String.format(RefreshCommand.MESSAGE_SUCCESS));
    }

    // -------------------------------invalid cases----------------------------------

    // test for invalid command

    @Test
    public void refresh_invalidCommand_fail() {
        commandBox.runCommand("refreshes");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

    }

    private void assertRefreshResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }

}
```
###### /java/seedu/toDoList/logic/AddCommandTest.java
``` java

/**
 * test for add command 
 * 
 * @author LiXiaowei
 * 
 * Use scenarios:
 *  - add a floating task 
 *  - add a deadline task (can be recurring)
 *  - add an event (can be recurring)
 *  
 *  Expected result:
 *  - the task specified is added to the toDoList
 *
 */
public class AddCommandTest extends CommandTest{
    
    
    //Invalid argument format
    @Test
    public void execute_add_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        assertCommandBehavior(
                "add Valid Name 02.03.2014 e/02.03.2014 t/validtag.butNoStartDatePrefix", expectedMessage);
        assertCommandBehavior(
                "add n/Valid Name s/02.03.2014 02.03.2014 t/validtag.butNoPrefix", expectedMessage);
        assertCommandBehavior(
                "add d/01.01.2016 t/validTag", expectedMessage);
        assertCommandBehavior("add",expectedMessage);
    }
    
    
    //Invalid data field
    @Test
    public void execute_add_invalidTaskData() throws Exception {
        //Invalid name
        assertCommandBehavior(
                "add n/[]\\[;] d/11.12.2016", Name.MESSAGE_NAME_CONSTRAINTS);
        //invalid recurring frequency
        assertCommandBehavior(
                "add n/Valid Name d/01.01.2016 r/everyday",Recurring.MESSAGE_RECURRING_CONSTRAINTS);
        //Invalid tag
        assertCommandBehavior(
                "add n/Valid Name d/11.12.2016-14 t/invalid_-[.tag", Tag.MESSAGE_TAG_CONSTRAINTS);
        
    }
    
    //test for missing recurring date exception
    @Test
    public void execute_add_invalidRecurringToFloatingTask() throws Exception{
        assertCommandBehavior(
                "add n/Valid Name r/daily",Recurring.RECURRING_MISSING_DATE);
    }
    
    /*
     * 2) Successful adding of floating task, deadline task and events
     *  - add floating task
     *  - add deadline task
     *  - add events
     *  - add recurring deadline task
     *  - add recurring event
     */

    @Test
    public void execute_addFloatingTask_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getFloatingTask();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_TASK_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    

    @Test
    public void execute_addDeadlineTask_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getDeadlineTask();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_TASK_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    

    @Test
    public void execute_addEvent_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getEvent();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_EVENT_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    
    @Test
    public void execute_addRecurringDeadlineTask_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getRecurringDeadlineTask();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_TASK_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    
    @Test
    public void execute_addRecurringEvent_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getRecurringEvent();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_EVENT_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    
    @Test
    public void execute_flexiAddEvent_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.getRecurringEvent();
        TaskManager expectedAB = new TaskManager();
        expectedAB.addTask(toBeAdded);
  
        // execute command and verify result
        assertCommandBehavior(helper.generateFlexiAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_EVENT_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskList());

    }
    
}
```
###### /java/seedu/toDoList/logic/CommandTest.java
``` java
    /**
     * A utility class to generate test data.
     */
    class TestDataHelper{

        Task getFloatingTask() throws Exception {
            Name name = new Name("Visit grandma");
            Tag tag1 = new Tag("tag1");
            UniqueTagList tags = new UniqueTagList(tag1);
            return new Task(name,tags, new Priority(0));
        }

        Task getDeadlineTask() throws Exception{
            Name name=new Name("project due");
            Date deadline=new Deadline("01.01.2016");
            return new Task(name,deadline,new UniqueTagList(), new Priority(0));
        }

        Task getDuplicateDeadlineTask() throws Exception{
            Name name=new Name("Visit grandma");
            Date deadline=new Deadline("01.01.2016-14");
            return new Task(name,deadline,new UniqueTagList(), new Priority(0));
        }

        Task getEvent() throws Exception{
            Name name=new Name("do homework");
            Date date=new EventDate("01.01.2016","02.01.2016");
            return new Task(name,date,new UniqueTagList(), new Priority(0));
        }

        Task getRecurringDeadlineTask() throws Exception{
            Name name=new Name("post on GitHub");
            Date deadline=new Deadline("02.03.2016");
            Recurring recurring=new Recurring("weekly");
            return new Task(name,deadline,new UniqueTagList(),recurring, new Priority(0));
        }

        Task getRecurringEvent() throws Exception{
            Name name=new Name("eat lunch");
            Date date=new EventDate("01.01.2016-14","02.01.2016-16");
            Recurring recurring=new Recurring("monthly");
            return new Task(name,date,new UniqueTagList(),recurring, new Priority(0));
        }



        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state.
         * Each unique seed will generate a unique Task object.
         *
         * @param seed used to generate the task data field values
         */
        Task generateTask(int seed) throws Exception {
            return new Task(new Name("Task " + seed), new Deadline("16.10.2016-14"),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1))),
                    new Priority(0));
        }

        /** Generates the correct add command based on the task given */
        String generateAddCommand(Task p) {
            StringBuffer cmd = new StringBuffer();
            cmd.append("add n/");
            cmd.append(p.getName().toString());
            if(p.isEvent()){
                EventDate date=(EventDate) p.getDate();
                cmd.append(" s/ ").append(date.getStartDate());
                cmd.append(" e/ ").append(date.getEndDate());
            }else{
            cmd.append(" d/").append(p.getDate());
            }
            UniqueTagList tags = p.getTags();
            for(Tag t: tags){
                cmd.append(" t/").append(t.tagName);
            }
            if(p.isRecurring())
                cmd.append("r/ "+p.getRecurring().recurringFrequency);
            return cmd.toString();
        }


        /** Generates the correct flexi add command based on the task given */
        public String generateFlexiAddCommand(Task p) {
            StringBuilder sb = new StringBuilder();
            sb.append("add ");
            if (p.getDate() instanceof EventDate) {
                EventDate eventDate = (EventDate) p.getDate();
                sb.append("e/" + eventDate.getEndDate() + " ");
                sb.append("s/" + eventDate.getStartDate() + " ");
            } else {
                assert p.getDate() instanceof Deadline;
                String deadline = p.getDate().getValue();
                if (!deadline.equals("")) {
                    sb.append("d/" + deadline + " ");
                }
            }
            sb.append("n/"+p.getName().taskName + " ");
            if(p.isRecurring()){
                sb.append("r/ "+p.getRecurring().recurringFrequency);
            }
            p.getTags().getInternalList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
            return sb.toString();
        }

        /**
         * Generates an TaskManager with auto-generated tasks.
         */
        TaskManager generateTaskManager(int numGenerated) throws Exception{
            TaskManager taskManager = new TaskManager();
            addToTaskManager(taskManager, numGenerated);
            return taskManager;
        }

        /**
         * Generates an TaskManager based on the list of Tasks given.
         */
        TaskManager generateTaskManager(List<Task> tasks) throws Exception{
            TaskManager taskManager = new TaskManager();
            addToTaskManager(taskManager, tasks);
            return taskManager;
        }

        /**
         * Adds auto-generated Task objects to the given TaskManager
         * @param taskManager The TaskManager to which the Tasks will be added
         */
        void addToTaskManager(TaskManager taskManager, int numGenerated) throws Exception{
            addToTaskManager(taskManager, generateTaskList(numGenerated));
        }

        /**
         * Adds the given list of Tasks to the given TaskManager
         */
        void addToTaskManager(TaskManager taskManager, List<Task> tasksToAdd) throws Exception{
            for(Task p: tasksToAdd){
                taskManager.addTask(p);
            }
        }

        /**
         * Adds auto-generated Task objects to the given model
         * @param model The model to which the Tasks will be added
         */
        void addToModel(Model model, int numGenerated) throws Exception{
            addToModel(model, generateTaskList(numGenerated));
        }

        /**
         * Adds the given list of Tasks to the given model
         */
        void addToModel(Model model, List<Task> tasksToAdd) throws Exception{
            for(Task p: tasksToAdd){
                model.addTask(p);
            }
        }

        /**
         * Generates a list of Tasks based on the flags.
         */
        List<Task> generateTaskList(int numGenerated) throws Exception{
            List<Task> tasks = new ArrayList<>();
            for(int i = 1; i <= numGenerated; i++){
                tasks.add(generateTask(i));
            }
            return tasks;
        }

        List<Task> generateTaskList(Task... tasks) {
            return Arrays.asList(tasks);
        }

        /**
         * Generates an undone Task object with given name. Other fields will have some dummy values.
         */
        Task generateUndoneTaskWithName(String name) throws Exception {
            return new Task(new Name(name), new Deadline("11.11.2016"), new UniqueTagList(new Tag("tag")),
                    new Priority(0));
        }

        /**
         * Generates an undone Task object with given deadline. Other fields will have some dummy values.
         */
        Task generateUndoneTaskWithDeadline(String deadline) throws Exception {
            return new Task(new Name("name"), new Deadline(deadline), new UniqueTagList(new Tag("tag")),
                    new Priority(0));
        }

        /**
         * Generates an undone Task object with given tag. Other fields will have some dummy values.
         */
        Task generateUndoneTaskWithTag(String tag) throws Exception {
            return new Task(new Name("name"), new Deadline("11.11.2016"), new UniqueTagList(new Tag(tag)),
                    new Priority(0));
        }

        /**
         * Generates a done Task object with given name. Other fields will have some dummy values.
         */
        Task generateDoneTaskWithName(String name) throws Exception {
            return new Task(new Name(name), new Deadline("11.11.2016"), new UniqueTagList(new Tag("tag")), true, false,
                    new Priority(0));
        }

        /**
         * Generates an undone Event object with given name. Other fields will have some dummy values.
         */
        Task generateUndoneEventWithName(String name) throws Exception {
            return new Task(new Name(name), new EventDate("11.11.2016", "12.11.2016"),
                    new UniqueTagList(new Tag("tag")), new Priority(0));
        }

        /**
         * Generates an undone Event object with given start date. Other fields will have some dummy values.
         */
        Task generateUndoneEventWithStartDate(String startDate) throws Exception {
            return new Task(new Name("name"), new EventDate(startDate, "12.11.2016"), new UniqueTagList(new Tag("tag")),
                    new Priority(0));
        }

        /**
         * Generates an undone Event object with given start date. Other fields will have some dummy values.
         */
        Task generateUndoneEventWithEndDate(String endDate) throws Exception {
            return new Task(new Name("name"), new EventDate("11.11.2016", endDate), new UniqueTagList(new Tag("tag")),
                    new Priority(0));
        }

        /**
         * Generates a done Event object with given name. Other fields will have some dummy values.
         */
        Task generateDoneEventWithName(String name) throws Exception {
            return new Task(new Name(name), new EventDate("11.11.2016", "12.11.2016"),
                    new UniqueTagList(new Tag("tag")), true, false, new Priority(0));
        }

    }
}
```
###### /java/seedu/toDoList/logic/DeleteCommandTest.java
``` java
/**
 * Responsible for testing the correct execution of DeleteCommand
 */
public class DeleteCommandTest extends CommandTest{
    
    /*
     * DeleteCommand format: delete index/name
     * 
     * 
     * Equivalence partitions for index: negative integer,positive integer exists in the list,non-integer,
     * positive integer that does not exist in the list
     * 
     * Equivalence partitions for name: alphanumeric characters that exists in the list
     * , non-alphanumeric characters, valid alphanumeric character name that does not exist in the list
     */
    
    
   //-------------------------test for invalid commands------------------------------------------------
    
    
    @Test
    public void execute_deleteInvalidArgsFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        assertAbsenceKeywordFormatBehaviorForCommand("delete", expectedMessage);
    }
    
    
    /*
     * Confirms the 'invalid argument index number behavior' for the given command
     * targeting a single task in the shown list, using visible index.
     */
    
    @Test
    public void execute_deleteInvalidIndexFormat_errorMessageShown() throws Exception{
        String expectedMessage=DeleteCommand.MESSAGE_DELETE_NOT_FOUND;
        assertCommandBehavior("delete",String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        assertCommandBehavior("delete" + " +1", expectedMessage); //index should be unsigned
        assertCommandBehavior("delete"+ " -1", expectedMessage); //index should be unsigned
        assertCommandBehavior("delete" + " 0", expectedMessage); //index cannot be 0 
        assertCommandBehavior("delete"+" 0.5 ",expectedMessage);//index should be a positive integer
    }

    //positive integer index that does not exist in the list
    
    @Test
    public void execute_deleteIndexNotFound_errorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand("delete");
    }
    
    
    //test for valid alphanumeric names that does not exist in the list
    
    @Test
    public void execute_deleteValidNameNotFound_errorMessageShown() throws Exception{
        TestDataHelper helper = new TestDataHelper();
        List<Task> threeTasks = helper.generateTaskList(3);

        TaskManager expectedAB = helper.generateTaskManager(threeTasks);

        assertAbsenceKeywordFormatBehaviorForCommand("delete go to school",DeleteCommand.MESSAGE_DELETE_NOT_FOUND);
        
    }
    
    
    //------------------------------test for valid cases------------------------------------------------
    
    
    /*
     * Valid test scenarios
     * 
     * Assumptions: all input parameters are correct
     * 
     * Possible scenarios:
     *  - Delete a task or event by index in the last shown list
     *  - Delete a task or event by name with only one unique occurrence in the last shown list
     *  - Delete a task or event by name with multiple occurrences in the last shown list
     * 
     * Corresponding expected result: 
     *  - task manager list no longer contains the specified task or event
     *  - a list of tasks or events with one or some of the input parameters is shown, then user
     *  is expected to delete by index in the last shown list
     *  - a list of tasks or events with one or some of the input parameters is shown, and the 
     *  user is expected to delete the task or event by index in the last shown list
     *  
     */
    
    //Test for the first scenario: delete a task or event by its valid index
    
    @Test
    public void execute_delete_removesCorrectTaskByIndex() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        List<Task> threeTasks = helper.generateTaskList(3);

        TaskManager expectedAB = helper.generateTaskManager(threeTasks);
        expectedAB.removeTask(threeTasks.get(1));
        helper.addToModel(model, threeTasks);

        assertCommandBehavior("delete 2",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, threeTasks.get(1)),
                expectedAB,
                expectedAB.getTaskList());
    }
    
    //Test for the second scenario: delete a task or event by its exact name
    
    @Test
    public void execute_delete_removesCorrectTaskByUniqueName() throws Exception{
        TestDataHelper helper=new TestDataHelper();
        List<Task> fourTasks=helper.generateTaskList(3);
        fourTasks.add(helper.getFloatingTask());
        
        TaskManager expectedAB=helper.generateTaskManager(fourTasks);
        List<Task> expectedList=helper.generateTaskList(fourTasks.get(3));
        helper.addToModel(model, fourTasks);
        
        assertCommandBehavior("delete Visit grandma", 
                String.format(DeleteCommand.MESSAGE_DELETE_SAME_NAME),
                expectedAB,expectedList);
    }
    
    //Test for the third scenario: delete a task or event with duplicated names

    @Test
    public void execute_delete_removesCorrectTaskByMultipleNameOccurrence() throws Exception{
        TestDataHelper helper=new TestDataHelper();
        List<Task> fiveTasks=helper.generateTaskList(3);
        fiveTasks.add(helper.getFloatingTask());
        fiveTasks.add(helper.getDuplicateDeadlineTask());
       
        TaskManager expectedAB = helper.generateTaskManager(fiveTasks);
        List<Task> expectedList = helper.generateTaskList(fiveTasks.get(3),fiveTasks.get(4));
        helper.addToModel(model, fiveTasks);

        assertCommandBehavior("delete Visit grandma",
                String.format(DeleteCommand.MESSAGE_DELETE_SAME_NAME),
                expectedAB,
                expectedList);
    }
    


}
```
###### /java/seedu/toDoList/logic/ListCommandTest.java
``` java

/**
 * Responsible for testing the correct execution of listCommand
 */


public class ListCommandTest extends CommandTest{
    
    /*
     * Format: list tasks/events/done/undone/empty_parameter
     * Equivalence partitions: tasks, events,done,undone,empty_parameter,any other invalid 
     * paramaters which do not belong to any of the above listed parameters
     * 
     */
    
    //----------------------------Invalid execution------------------------------------------
    
    //test for valid command format
    
    
    @Test
    public void execute_listInvalidFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(ListCommand.MESSAGE_INVALID_LIST_COMMAND, ListCommand.MESSAGE_USAGE);
        assertAbsenceKeywordFormatBehaviorForCommand("list task", expectedMessage);
        
    }
    
    
    //-----------------------------Correct execution------------------------------------------
    
    
    //correct execution of scenario "list"
    
    @Test
    public void execute_list_showsAll() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateUndoneTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateDoneTaskWithName("bla KEY bla bceofeia");
        Task p3 = helper.generateUndoneEventWithName("KE Y");
        Task p4 = helper.generateDoneEventWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, p2,p3,p4);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(p1,p2,p3,p4);
        helper.addToModel(model, fourTasks);

        assertCommandBehavior("list",
                ListCommand.MESSAGE_SUCCESS,
                expectedAB,
                expectedList);
    }
    
    
    
    //correct execution of scenario "list tasks"
    
    @Test
    public void execute_list_showsTasks() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateUndoneTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateDoneTaskWithName("bla KEY bla bceofeia");
        Task p3 = helper.generateUndoneEventWithName("KE Y");
        Task p4 = helper.generateDoneEventWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(pTarget1, pTarget2,p3,p4);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1,pTarget2);
        helper.addToModel(model, fourTasks);

        assertCommandBehavior("list tasks",
                ListCommand.MESSAGE_TASK_SUCCESS,
                expectedAB,
                expectedList);
    
    }
    
    
    //correct execution of scenario "list events"
    
    @Test
    public void execute_list_showsEvents() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateUndoneTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateDoneTaskWithName("bla KEY bla bceofeia");
        Task pTarget3 = helper.generateUndoneEventWithName("KE Y");
        Task pTarget4 = helper.generateDoneEventWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, p2,pTarget3,pTarget4);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget3,pTarget4);
        helper.addToModel(model, fourTasks);

        assertCommandBehavior("list events",
                ListCommand.MESSAGE_EVENT_SUCCESS,
                expectedAB,
                expectedList);
    
    }
    
    
    //correct execution of scenario "list done"
    
    @Test
    public void execute_list_showsDoneTasksAndEvents() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateUndoneTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateDoneTaskWithName("bla KEY bla bceofeia");
        Task p3 = helper.generateUndoneEventWithName("KE Y");
        Task pTarget4 = helper.generateDoneEventWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, pTarget2,p3,pTarget4);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget2,pTarget4);
        helper.addToModel(model, fourTasks);

        assertCommandBehavior("list done",
                ListCommand.MESSAGE_LIST_DONE_TASK_SUCCESS,
                expectedAB,
                expectedList);
    }
    
    //correct execution of scenario "list undone"
    
    @Test
    public void execute_list_showsUndoneTasksAndEvents() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateUndoneTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateDoneTaskWithName("bla KEY bla bceofeia");
        Task pTarget3 = helper.generateUndoneEventWithName("KE Y");
        Task p4 = helper.generateDoneEventWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(pTarget1, p2,pTarget3,p4);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1,pTarget3);
        helper.addToModel(model, fourTasks);

        assertCommandBehavior("list undone",
                ListCommand.MESSAGE_LIST_UNDONE_TASK_SUCCESS,
                expectedAB,
                expectedList);
    }
    


}
```
###### /java/seedu/toDoList/model/RecurringTest.java
``` java

/*
 * Tests for updating out-dated recurring tasks
 */
public class RecurringTest {
    
    //--------------------------Tests for updating deadline------------------------------------
    
    /*
     * Equivalence partitions for DeadlineFormat:
     *  - deadline of dateFormat "dd.MM.yyyy"
     *  - deadline of dateTimeFormat "dd.MM.yyyy-XX"
     *  
     *  Equivalence partitions for numDaysToUpdate:
     *  - existing date + numDaysToUpdate < numDaysInCurrentMonth
     *  - existing date + numDaysToUpdate > numDaysInCurrentMonth
     *  
     */
    
    //test for deadlineDateFormat, numDaysToUpdate + existing date < numDaysInCurrentMonth
    @Test
    public void refresh_updateDeadlineDateFormat_success() throws IllegalValueException{
        Deadline d1=new Deadline("01.01.2016");
        d1.updateRecurringDate(2);
        assertEquals("03.01.2016",d1.getValue());
    }
    
    //test for deadlineDateTimeFormat, numDaysToUpdate + existing date < numDaysInCurrentMonth
    @Test
    public void refresh_updateDeadlineDateTimeFormat_succcess() throws IllegalValueException{
        Deadline d2=new Deadline("01.01.2016-14");
        d2.updateRecurringDate(14);
        assertEquals("15.01.2016-14",d2.getValue());
    }
    
    //test for numDaysToUpdate + existing date > numDaysInCurrentMonth
    @Test
    public void refresh_updateNumDaysExceedCurrentMonth_success() throws IllegalValueException{
        Deadline d3=new Deadline("01.02.2016-14");
        d3.updateRecurringDate(60);
        assertEquals("01.04.2016-14",d3.getValue());
    }
    
    //-----------------------------Tests for updating eventDate-------------------------------
    
    /*
     * Equivalence partitions for event date format:
     *  - eventDateFormat ( "dd.MM.yyyy", "dd.MM.yyyy" )
     *  - eventDateTimeFormat ( "dd.MM.yyyy-XX", "dd.MM.yyyy-XX")
     *  - eventDateTimeMixedFormat ( "dd.MM.yyyy-XX", "dd.MM.yyyy" )
     */
    
    //test eventDateFormat with numDaysToUpdate + existingDate > numDaysInMonth
    @Test
    public void refresh_updateEventDateFormat_success() throws IllegalValueException{
        EventDate d4=new EventDate("01.02.2016","02.02.2016");
        d4.updateRecurringDate(60);
        assertEquals(d4.getValue(),"01.04.2016 to 02.04.2016");
    }
    
    //test eventDateTimeFormat with numDaysToUpdate + existingDate < numDaysInMonth
    @Test
    public void refresh_updateEventDateTimeFormat_success() throws IllegalValueException{
        EventDate d5=new EventDate("01.01.2016-14","02.01.2016-16");
        d5.updateRecurringDate(3);
        assertEquals(d5.getValue(),"04.01.2016-14 to 05.01.2016-16");
    }
    
    //test eventDateTimeMixedFormat
    @Test
    public void refresh_updateEventDateTimeMixedFormat_success() throws IllegalValueException{
        EventDate d6=new EventDate("01.01.2016-16","02.01.2016");
        d6.updateRecurringDate(3);
        assertEquals(d6.getValue(),"04.01.2016-16 to 05.01.2016");
    }
    
    
}
```
###### /java/seedu/toDoList/testutil/TestTask.java
``` java
    public String getFlexiAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add ");
        if (isCustomizedPriority) {
            sb.append("p/" + priorityLevel.priorityLevel);
        }
        if (isEvent) {
            assert date instanceof EventDate;
            EventDate eventDate = (EventDate) this.getDate();
            sb.append("e/" + eventDate.getEndDate() + " ");
            sb.append("s/" + eventDate.getStartDate() + " ");
        } else {
            assert date instanceof Deadline;
            String deadline = this.getDate().getValue();
            if (!deadline.equals("")) {
                sb.append("d/" + deadline + " ");
            }
        }
        if (isRecurring) {
            sb.append("r/" + recurring.recurringFrequency);
        }
        sb.append("n/" + this.getName().taskName + " ");
        this.getTags().getInternalList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }

    @Override
    public Recurring getRecurring() {
        return recurring;
    }

    @Override
    public boolean isRecurring() {
        return isRecurring;
    }

}
```
###### /java/seedu/toDoList/testutil/TestUtil.java
``` java

    /**
     * 
     * @return string representing the next upcoming Friday's date
     */
    public static String getNextFriday() {
        Calendar c = Calendar.getInstance();
        DateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
        c.setTime(c.getTime());

        // search until the next upcoming Friday
        while (c.get(Calendar.DAY_OF_WEEK) != Calendar.FRIDAY) {
            c.add(Calendar.DAY_OF_WEEK, 1);
        }
        return dateFormat.format(c.getTime());
    }

    public static String getNextMonthDate(String existingDate) {
        LocalDate date = LocalDate.parse(existingDate, DateUtil.getGermanFormatter());
        long numDaysToUpdate = DateUtil.getElapsedDaysFromCurrentDate(date);

        if (numDaysToUpdate > Task.RECURRING_UPDATE_THRESHOLD) {
            date = date.plusDays(( ( numDaysToUpdate - 1 ) / Task.DAYS_OF_MONTH + 1 ) * Task.DAYS_OF_MONTH);
        }

        return DateUtil.getFormattedDateString(date);
    }

}
```
