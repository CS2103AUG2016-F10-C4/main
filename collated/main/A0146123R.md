# A0146123R
###### /java/seedu/address/commons/events/storage/RedoStoragePathChangedEvent.java
``` java
/**
 * Indicates should redo the change for the path for the storage file
 */
public class RedoStoragePathChangedEvent extends BaseEvent {
    
    public boolean isToClearOld;
    
    public RedoStoragePathChangedEvent(boolean isToClearOld) {
        this.isToClearOld = isToClearOld;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/address/commons/events/storage/StoragePathChangedBackEvent.java
``` java
/**
 * Indicates the path for the storage file should be changed back
 */
public class StoragePathChangedBackEvent extends BaseEvent {
    
    public boolean isToClearNew;
    
    public StoragePathChangedBackEvent(boolean isToClearNew) {
        this.isToClearNew = isToClearNew;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/address/commons/events/storage/StoragePathChangedEvent.java
``` java
/**
 * Indicates the path for the storage file has changed
 */
public class StoragePathChangedEvent extends BaseEvent {

    public String newStorageFilePath;
    public boolean isToClearOld;
    
    public StoragePathChangedEvent(String newStorageFilePath, boolean isToClearOld) {
        assert newStorageFilePath != null;
        
        this.newStorageFilePath = newStorageFilePath;
        this.isToClearOld = isToClearOld;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
}
```
###### /java/seedu/address/commons/exceptions/StateLimitException.java
``` java
/**
 * Represents an error caused by no more states to get. 
 */
public class StateLimitException extends Exception{
    public StateLimitException() {
        super();
    }
}
```
###### /java/seedu/address/commons/util/DateUtil.java
``` java
/**
 * Utility methods related to Dates
 */
public class DateUtil {

    private static final String DATE_VALIDATION_REGEX = "^[0-3][0-9].[0-1][0-9].([0-9]{4})(-[0-2]?[0-9]?)?";
    // EXAMPLE = "15.10.2016-14"

    private static final DateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
    private static final DateFormat dateTimeFormat = new SimpleDateFormat("dd.MM.yyyy-HH");
    private static final String EMPTY = "";
    private static final String TIME_SEPERATOR = "-";

    /**
     * Returns true if the given string is in a valid date format.
     */
    public static boolean isValidDateFormat(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }

    /**
     * Returns true if the given string is an empty deadline.
     */
    public static boolean isEmptyDate(String test) {
        return test.equals(EMPTY);
    }

    /**
     * Parse the given date.
     * 
     * @return a String that represents a valid date (i.e. if the user input
     *         31.04.2016, it will be corrected to 01.05.2016)
     * @throws IndexOutOfBoundsException
     *             if the given date cannot be parsed
     */
    public static String parseDate(String date) throws IndexOutOfBoundsException {
        String[] parts = date.split(TIME_SEPERATOR);
        if (parts.length == 1) {
            try {
                return dateFormat.format(dateFormat.parse(date));
            } catch (ParseException e) {
                return parseNotFormattedDate(date);
            }
        }
        try {
            return dateTimeFormat.format(dateTimeFormat.parse(date));
        } catch (ParseException e) {
            return parseNotFormattedDate(date);
        }
    }

```
###### /java/seedu/address/commons/util/TypesUtil.java
``` java
    public static final String EVENTS = "events";
    public static final String TASKS = "tasks";
    public static final String DONE = "done";
    public static final String UNDONE = "undone";
    public static final String START_DATE = "startDate";
    public static final String END_DATE = "endDate";
    public static final String DEADLINE = "deadline";
    public static final String RECURRING = "recurring";
    public static final String TAG = "tag";
```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Add an event with a starting and ending date or a task (with or without deadline) to the task manager.\n"
            + "Parameters: n/EVENT_NAME s/START_DATE e/END_DATE [p/PRIORITY_LEVEL] [t/TAG]... or n/TASK_NAME [d/DEADLINE] [p/PRIORITY_LEVEL] [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " n/Lecture s/7.10.2016-14 e/7.10.2016-16 p/1 t/CS2103, add n/Project Deadline d/14.10.2016 p/3 t/CS2103";

    public static final String MESSAGE_EVENT_SUCCESS = "New event added: %1$s";
    public static final String MESSAGE_TASK_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "It's already exists in the task manager";

    private final Task toAdd;

```
###### /java/seedu/address/logic/commands/ChangeCommand.java
``` java
/**
 * Changes the default storage location of the task manager.
 */
public class ChangeCommand extends Command{

    public static final String COMMAND_WORD = "change";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Change the default storage location to the specified location (must end with the file type extension, .xml)"
            + " and clear data saved in the previous location if specified.\n" 
            + "Parameters: FILE_PATH [clear]\n"
            + "Example: " + COMMAND_WORD
            + " /Desktop/folder/taskManager.xml clear";

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location has been changed!";
    public static final String MESSAGE_INVALID_FILE_PATH = "The file path provided is invalid."
            + " It must end with the file type extension, .xml";
    public static final String MESSAGE_INVALID_CLEAR_DATA = "The clear data argument provided is invalid.";
    
    private static final String CLEAR = "clear";
    
    private final String filePath;
    private final String clear;
    private final boolean isToClearOld;
    
    /**
     * Convenience constructor using raw values.
     */
    public ChangeCommand(String filePath, String clear) {
        this.filePath = filePath;
        this.clear = clear;
        this.isToClearOld = true;
    }
    
    public ChangeCommand(String filePath) {
        this.filePath = filePath;
        this.clear = "";
        this.isToClearOld = false;
    }

    @Override
    public CommandResult execute() {
        assert filePath != null;
        assert clear != null;
        
        if (!isValidPath(filePath) || !isXml(filePath)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_FILE_PATH);
        }
        if (isToClearOld && !isValidClear()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_CLEAR_DATA);
        }
        model.updateTaskManager(filePath, isToClearOld);
        UndoChangeCommand.undoable = true;
        RedoChangeCommand.redoable = false;
        RedoChangeCommand.isToClearOld = isToClearOld;
        return new CommandResult(MESSAGE_CHANGE_SUCCESS);
    }

    private boolean isValidPath(String path) {
        try {
            Paths.get(path);
        } catch (InvalidPathException e) {
            return false;
        }
        return true;
    }
    
    private boolean isXml(String path) {
        return path.endsWith(".xml");
    }
    
    private boolean isValidClear() {
        return clear.equals(CLEAR);
    }
    
}
```
###### /java/seedu/address/logic/commands/FilterCommand.java
``` java
/**
 * Filter the filtered task list to filter by the given attribute.
 */
public class FilterCommand extends Command {

    public static final String COMMAND_WORD = "filter";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Filter list for specified attributes "
            + "and displays them as a list with index numbers.\n"
            + "Parameters: [s/START_DATE] [e/END_DATE] [d/DEADLINE] [r/RECURRING] [p/PRIORITY] [t/TAG]...\n" + "Example: "
            + COMMAND_WORD + " s/23.10.2016 r/daily";

    private final Optional<String> deadline;
    private final Optional<String> startDate;
    private final Optional<String> endDate;
    private final Optional<String> recurring;
    private final Set<String> tags;
    private final Optional<String> priority;

    public FilterCommand(Optional<String> deadline, Optional<String> startDate, Optional<String> endDate,
            Optional<String> recurring, Set<String> tags, Optional<String> priority) {
        this.deadline = deadline;
        this.startDate = startDate;
        this.endDate = endDate;
        this.recurring = recurring;
        this.tags = tags;
        this.priority = priority;
    }

    @Override
    public CommandResult execute() {
        Map<String, String> filterQualifications = new HashMap<>();
        try {
            if (deadline.isPresent()) {
                String deadlineString = Deadline.getValidDate(deadline.get());
                filterQualifications.put(TypesUtil.DEADLINE, deadlineString);
            }
            if (startDate.isPresent()) {
                String startDateString = EventDate.getValidDate(startDate.get());
                filterQualifications.put(TypesUtil.START_DATE, startDateString);
            }
            if (endDate.isPresent()) {
                String endDateString = EventDate.getValidDate(endDate.get());
                filterQualifications.put(TypesUtil.END_DATE, endDateString);
            }
            if (recurring.isPresent()) {
                if (Recurring.isValidFrequency(recurring.get())) {
                    filterQualifications.put(TypesUtil.RECURRING, recurring.get());
                } else {
                    throw new IllegalValueException(Recurring.MESSAGE_RECURRING_CONSTRAINTS);
                }
            }
            if (priority.isPresent()) {
                if (Priority.isValidPriorityLevel(Integer.parseInt(priority.get())))
                    filterQualifications.put(TypesUtil.PRIORITY, priority.get());
                else
                    throw new IllegalValueException(Priority.MESSAGE_INVALID_PRIORITY_LEVEL);
            }
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(e.getMessage());
        }
        model.updateFilteredTaskList(filterQualifications, tags);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/address/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords or all of the argument keywords. Keyword matching is not
 * case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Case-insensitive. By default, finds all tasks with names containing any of "
            + "the specified keywords and the matching will only compare word stems of keywords.\n"
            + "Only events and tasks matching the exact keyword will be returned if the command contains the exact! parameter.\n"
            + "Only events and tasks matching both groups of keywords will be returned if the two groups of keywords are connected by AND.\n"
            + "Parameters: KEYWORD [AND] [MORE_KEYWORDS] [exact!]\n" 
            + "Example: " + COMMAND_WORD + " horror night, " + COMMAND_WORD + " horror AND night exact!";

    private final Set<Set<String>> keywordsGroups;
    private final boolean isExactSearch;

    public FindCommand(Set<Set<String>> keywordsGroups, boolean isExactSearch) {
        this.keywordsGroups = keywordsGroups;
        this.isExactSearch = isExactSearch;
    }

    @Override
    public CommandResult execute() {
        if (isExactSearch) {
            model.updateFilteredTaskListWithKeywords(keywordsGroups);
        } else {
            model.updateFilteredTaskListWithStemmedKeywords(keywordsGroups);
        }
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/address/logic/commands/RedoChangeCommand.java
``` java
/**
 * Redo change the storage location of the task manager.
 */
public class RedoChangeCommand extends Command {
    
    public static final String COMMAND_WORD = "redochange";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo change the default storage location back to the new location"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location has been changed!";
    public static final String MESSAGE_REDO_FAILED = "No undo change command to redo.";
    public static boolean redoable = false;
    public static boolean isToClearOld = false;
    
    @Override
    public CommandResult execute() {
        if (!redoable) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_REDO_FAILED);
        }
        model.redoUpdateTaskManager(isToClearOld);
        redoable = false;
        UndoChangeCommand.undoable = true;
        return new CommandResult(MESSAGE_CHANGE_SUCCESS);
    }
    
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
/*
 * Redoes the most recent undo action.
 */
public class RedoCommand extends Command{
    
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_REDO_SUCCESS = "Redid the most recent undo action:\n";
    public static final String MESSAGE_REDO_FAILED = "No command to redo.";

    @Override
    public CommandResult execute() {
        try {
            String message = model.getNextState();
            return new CommandResult(MESSAGE_REDO_SUCCESS + message);
        } catch (StateLimitException e){
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_REDO_FAILED);
        }
    }

}
```
###### /java/seedu/address/logic/commands/UndoChangeCommand.java
``` java
/**
 * Undo change the storage location of the task manager.
 */
public class UndoChangeCommand extends Command {
    
    public static final String COMMAND_WORD = "undochange";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Change the default storage location back to the previous location"
            + " and clear data saved in the new location if specified.\n" 
            + "Parameters: [clear]\n"
            + "Example: " + COMMAND_WORD
            + " clear";

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location has been changed back!";
    public static final String MESSAGE_UNDO_FAILED = "No change command to undo.";
    public static final String MESSAGE_INVALID_CLEAR_DATA = "The clear data argument provided is invalid.";
    public static boolean undoable = false;
    
    private static final String CLEAR = "clear";
    private static final String EMPTY = "";
    
    private final String clear;
    private final boolean isToClearNew;
    
    /**
     * Convenience constructor using raw values.
     */
    public UndoChangeCommand(String clear) {
        this.clear = clear.trim();
        this.isToClearNew = !this.clear.equals(EMPTY);
    }
    
    @Override
    public CommandResult execute() {
        assert clear != null;
        
        if (!undoable) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_UNDO_FAILED);
        }
        if (isToClearNew && !isValidClear()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_CLEAR_DATA);
        }
        model.changeBackTaskManager(isToClearNew);
        undoable = false;
        RedoChangeCommand.redoable = true;
        return new CommandResult(MESSAGE_CHANGE_SUCCESS);
    }
    
    private boolean isValidClear() {
        return clear.equals(CLEAR);
    }

}
```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
/** 
 * Undoes the most recent action (up to 5 times).  
 */
public class UndoCommand extends Command{
    
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_UNDO_SUCCESS = "Undid the most recent action:\n";
    public static final String MESSAGE_UNDO_FAILED = "No command to undo.";

    @Override
    public CommandResult execute() {
        try {
            String message = model.getPreviousState();
            return new CommandResult(MESSAGE_UNDO_SUCCESS + message);
        } catch (StateLimitException e){
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_UNDO_FAILED);
        }
    }

}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // Group keywords by AND operator
        final String[] keywords = matcher.group("keywords").split("AND");
        // keywords delimited by whitespace
        final Set<Set<String>> keywordsGroup = new HashSet<Set<String>>();
        for (String keyword : keywords) {
            keywordsGroup.add(new HashSet<>(Arrays.asList(keyword.trim().split("\\s+"))));
        }
        return new FindCommand(keywordsGroup, matcher.group("keywords").contains("exact!"));
    }

```
###### /java/seedu/address/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the change storage location command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareChange(String arguments) {
        final String[] args = arguments.trim().split("\\s+");
        if (args.length >= 0) {
            String filePath = args[0];
            if (args.length == 1) {
                return new ChangeCommand(filePath);
            } else if (args.length == 2) {
                String clear = args[1];
                return new ChangeCommand(filePath, clear);
            }
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeCommand.MESSAGE_USAGE));
    }

    /**
     * Parses arguments in the context of the filter attributes command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFilter(String arguments) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(deadlinePrefix, startDatePrefix, endDatePrefix,
                recurringPrefix, tagPrefix, priorityPrefix);
        argsTokenizer.tokenize(arguments);
        Optional<String> deadline = argsTokenizer.getValue(deadlinePrefix);
        Optional<String> startDate = argsTokenizer.getValue(startDatePrefix);
        Optional<String> endDate = argsTokenizer.getValue(endDatePrefix);
        Optional<String> recurring = argsTokenizer.getValue(recurringPrefix);
        Optional<List<String>> tags = argsTokenizer.getAllValues(tagPrefix);
        Optional<String> priority = argsTokenizer.getValue(priorityPrefix);
        if (deadline.isPresent() || startDate.isPresent() || endDate.isPresent() || recurring.isPresent()
                || tags.isPresent() || priority.isPresent()) {
            return new FilterCommand(deadline, startDate, endDate, recurring, toSet(tags), priority);
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/address/MainApp.java
``` java
    @Subscribe
    public void handleStoragePathChangedEvent(StoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        //Update config file
        this.config.setTaskManagerFilePath(event.newStorageFilePath);
        try {
            ConfigUtil.saveConfig(config, configFilePathUsed);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }
```
###### /java/seedu/address/model/Model.java
``` java
    /**
     * Updates the filter of the filtered task list to filter by the given type
     */
    void updateFilteredTaskList(String type);

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords of the given type
     */
    void updateFilteredTaskList(String keyword, String type);

    /**
     * Updates the filter of the filtered task list to filter by multiple
     * qualifications
     */
    void updateFilteredTaskList(Map<String, String> qualifications, Set<String> tags);
    
    /**
     * Updates the filter of the filtered task list to filter by multiple
     * types and qualifications
     */
    void updateFilteredTaskList(Set<String> types, Map<String, String> qualifications, Set<String> tags);

    /**
     * Updates the filter of the filtered task list to filter by the the given
     * keywords (for find command)
     */
    void updateFilteredTaskListWithKeywords(Set<Set<String>> keywordsGroups);

    /**
     * Updates the filter of the filtered task list to filter by the stemmed
     * words of the given keywords (for find command)
     */
    void updateFilteredTaskListWithStemmedKeywords(Set<Set<String>> keywordsGroups);

    /** Updates the filter of the filtered task list to filter by the given tags */
    void updateFilteredTaskListByTags(Set<String> keywords);

    /** Update the task manager to the new file path */
    void updateTaskManager(String filePath, boolean isToClearOld);

    /** Change the task manager back to the old file path */
    void changeBackTaskManager(boolean isToClearNew);

    /** Redo update the task manager back to the new file path */
    void redoUpdateTaskManager(boolean isToClearOld);

    /** Saves the current state of the task manager. */
    public void saveState(String message);

    /** Update the task manager to the previous state. */
    String getPreviousState() throws StateLimitException;

    /** Update the task manager to the next state. */
    String getNextState() throws StateLimitException;
    
    /**
     * Redo saves the current version of the Task Manager to the new file in hard disk.
     *   Delete the new data file if it was previously specified.
     */
    void handleFilterPanelChangedEvent(FilterPanelChangedEvent abce);

```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void updateTaskManager(String filePath, boolean isToClearOld) {
        EventsCenter.getInstance().post(new StoragePathChangedEvent(filePath, isToClearOld));
        indicateTaskManagerChanged();
    }

    @Override
    public void changeBackTaskManager(boolean isToClearNew) {
        EventsCenter.getInstance().post(new StoragePathChangedBackEvent(isToClearNew));
        indicateTaskManagerChanged();
    }

    @Override
    public void redoUpdateTaskManager(boolean isToClearOld) {
        EventsCenter.getInstance().post(new RedoStoragePathChangedEvent(isToClearOld));
        indicateTaskManagerChanged();
    }

    @Override
    public void saveState(String message) {
        stateManager.saveState(new TaskManagerState(taskManager, message));
    }

    @Override
    public String getPreviousState() throws StateLimitException {
        TaskManagerState previousState = stateManager.getPreviousState();
        return getState(previousState);
    }

    @Override
    public String getNextState() throws StateLimitException {
        TaskManagerState nextState = stateManager.getNextState();
        return getState(nextState);
    }

    private String getState(TaskManagerState state) {
        resetData(state.getTaskManager());
        return state.getMessage();
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(String keyword, String type) {
        updateFilteredTaskList(getPredicateForKeywordType(type, keyword));
    }

    private Expression getPredicateForKeywordType(String type, String keyword) {
    	switch (type) {
        case TypesUtil.START_DATE:
        case TypesUtil.DEADLINE:
        case TypesUtil.END_DATE:
            return new PredicateExpression(new DateQualifier(keyword, type));
        case TypesUtil.RECURRING:
            return new PredicateExpression(new RecurringQualifier(keyword));
        case TypesUtil.PRIORITY:
        	return new PredicateExpression(new PriorityQualifier(Integer.parseInt(keyword)));
        default:
            return null;
        }
    }

    @Override
    public void updateFilteredTaskList(Map<String, String> qualifications, Set<String> tags) {
        updateFilteredTaskListAndOperation(getPredicateForMultipleQualifications(qualifications, tags));
    }

    private ArrayList<Expression> getPredicateForMultipleQualifications(Map<String, String> qualifications,
            Set<String> tags) {
        ArrayList<Expression> predicate = new ArrayList<>();
        qualifications.forEach((type, keyword) -> predicate.add(getPredicateForKeywordType(type, keyword)));
        if (!tags.isEmpty()) {
            predicate.add(getPredicateForTags(tags));
        }
        return predicate;
    }

    @Override
    public void updateFilteredTaskList(Set<String> types, Map<String, String> qualifications, Set<String> tags) {
        ArrayList<Expression> predicate = getPredicateForMultipleQualifications(qualifications, tags);
        types.forEach(type -> predicate.add(getPredicateForType(type)));
        updateFilteredTaskListAndOperation(predicate);
    }

    @Override
    public void updateFilteredTaskListWithKeywords(Set<Set<String>> keywordsGroups) {
        ArrayList<Expression> predicate = new ArrayList<>();
        for (Set<String> keywords : keywordsGroups) {
            predicate.add(new PredicateExpression(new NameQualifier(keywords)));
        }
        updateFilteredTaskListAndOperation(predicate);
    }

    @Override
    public void updateFilteredTaskListWithStemmedKeywords(Set<Set<String>> keywordsGroups) {
        ArrayList<Expression> predicate = new ArrayList<>();
        for (Set<String> keywords : keywordsGroups) {
            predicate.add(new PredicateExpression(new StemmedNameQualifier(keywords)));
        }
        updateFilteredTaskListAndOperation(predicate);
    }

    @Override
    public void updateFilteredTaskListByTags(Set<String> keyword) {
        updateFilteredTaskList(getPredicateForTags(keyword));
    }

    private Expression getPredicateForTags(Set<String> keyword) {
        return new PredicateExpression(new TagQualifier(keyword));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    private void updateFilteredTaskListAndOperation(ArrayList<Expression> expression) {
        Predicate<? super Task> predicate;
        Predicate<Task> predicates = task -> true;
        for (Expression e : expression) {
            predicate = task -> e.satisfies(task);
            predicates = predicates.and(predicate);
        }
        filteredTasks.setPredicate(predicates);
    }

    @Subscribe
    @Override
    public void handleFilterPanelChangedEvent(FilterPanelChangedEvent abce) {
        updateFilteredTaskList(abce.getTypes(), abce.getQualifications(), abce.getTags());
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class StemmedNameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        StemmedNameQualifier(Set<String> nameKeyWords) {
            Stemmer stemmer = new Stemmer();
            this.nameKeyWords = nameKeyWords.stream().map(keyword -> stemmer.stem(keyword))
                    .collect(Collectors.toSet());
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            Set<String> taskName = getStemmedTaskName(task);
            Stemmer stemmer = new Stemmer();
            return nameKeyWords.stream()
                    .filter(keyword -> taskName.stream()
                            .map(name -> stemmer.stem(name))
                            .filter(name -> name.equals(keyword)).count() > 0)
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "stemmed name=" + String.join(", ", nameKeyWords);
        }

        private Set<String> getStemmedTaskName(ReadOnlyTask task) {
            String[] taskName = task.getName().taskName.split("\\s+");
            return new HashSet<>(Arrays.asList(taskName));
        }
    }

```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private final String TIME_SEPERATOR = "-";
        private final int NUM_OF_PARTS_DAY = 1;
        private final int DAY = 0;

        private String dateValue;
        private String dateType;
        private boolean isEvent;
        private boolean isDay;

        DateQualifier(String dateValue, String dateType) {
            assert dateValue != null;
            this.dateValue = dateValue.trim();
            this.dateType = dateType;
            this.isEvent = dateType.equals(TypesUtil.DEADLINE) ? false : true;
            this.isDay = isDay(this.dateValue);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.isEvent() == isEvent) {
                switch (dateType) {
                case TypesUtil.START_DATE:
                    return isDay ? getDay(((EventDate) task.getDate()).getStartDate()).equals(dateValue)
                            : ((EventDate) task.getDate()).getStartDate().equals(dateValue);
                case TypesUtil.END_DATE:
                    return isDay ? getDay(((EventDate) task.getDate()).getEndDate()).equals(dateValue)
                            : ((EventDate) task.getDate()).getEndDate().equals(dateValue);
                case TypesUtil.DEADLINE:
                    return isDay ? getDay(task.getDate().getValue()).equals(dateValue)
                            : task.getDate().getValue().equals(dateValue);
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return "date type=" + dateType + " date=" + dateValue;
        }

        private boolean isDay(String date) {
            return date.split(TIME_SEPERATOR).length == NUM_OF_PARTS_DAY;
        }

        private String getDay(String date) {
            return date.split(TIME_SEPERATOR)[DAY];
        }
    }

```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream().filter(keyword -> {
                try {
                    return task.getTags().contains(new Tag(keyword));
                } catch (IllegalValueException e) {
                    return false;
                }
            }).findAny().isPresent();
        }

        @Override
        public String toString() {
            return "tags=" + String.join(", ", tagKeyWords);
        }
    }

```
###### /java/seedu/address/model/state/State.java
``` java
/**
 * The API of the State component.
 */
public interface State {
    
    /** Saves the current state of the task manager. */
    public void saveState(TaskManagerState state);
    
    /** Gets the previous state of the task manager. */
    public TaskManagerState getPreviousState() throws StateLimitException;
    
    /** Gets the next state of the task manager. */
    public TaskManagerState getNextState() throws StateLimitException;
    
}
```
###### /java/seedu/address/model/state/StateManager.java
``` java
/**
 * Saves the states of the task manager.
 */
public class StateManager implements State {
    
    // Undo/Redo up to 5 times
    private static final int CAPACITY = 5;
    
    private TaskManagerState currentState;
    private LinkedList<TaskManagerState> undoStates;
    private LinkedList<TaskManagerState> redoStates;
    
    public StateManager(TaskManagerState initialState) {
        currentState = initialState;
        undoStates = new LinkedList<TaskManagerState>();
        redoStates = new LinkedList<TaskManagerState>();
    }
    
    public void saveState(TaskManagerState state) {
        if (undoStates.size() == CAPACITY) {
            undoStates.removeFirst();
        }
        undoStates.add(currentState);
        currentState = state;
        redoStates.clear();
        
        assert undoStates.size() <= CAPACITY;
    }

    @Override
    public TaskManagerState getPreviousState() throws StateLimitException{
        if (undoStates.size() == 0) {
            throw new StateLimitException();
        }
        redoStates.add(currentState);
        currentState = undoStates.removeLast();
        return currentState;
    }

    @Override
    public TaskManagerState getNextState() throws StateLimitException{
        if (redoStates.size() == 0) {
            throw new StateLimitException();
        }
        undoStates.add(currentState);
        currentState = redoStates.removeLast();
        return currentState;
    }
    
}
```
###### /java/seedu/address/model/state/TaskManagerState.java
``` java
/**
 * Represent the state of task manager.
 */
public class TaskManagerState {
    
    private final ReadOnlyTaskManager taskManager;
    private final String message;
    
    public TaskManagerState(ReadOnlyTaskManager taskManager, String message) {
        this.taskManager = new TaskManager(taskManager);
        this.message = message;
    }
    
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }
    
    public String getMessage() {
        return message;
    }
}
```
###### /java/seedu/address/model/task/Date.java
``` java
/**
 * Represents a Task's date
 * It can be deadline for tasks or event date for events.
 */
public interface Date {
    
    String getValue();
    
    String toString();
  
    int hashCode();
    
    default boolean isEmptyDate() {
        return DateUtil.isEmptyDate(getValue());
    }
}
```
###### /java/seedu/address/model/task/Deadline.java
``` java
/**
 * Represents a Task's deadline. Empty String "" means no deadline (floating
 * task) Guarantees: is valid as declared in
 * {@link #isValidDeadlineFormat(String)}
 */
public class Deadline implements Date {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline must be a valid date";

    private String date;

    /**
     * Validates given deadline.
     *
     * @throws IllegalValueException
     *             if given deadline string is invalid.
     */
    public Deadline(String date) throws IllegalValueException {
        assert date != null;
        this.date = getValidDate(date);
        assert isValidDeadlineFormat(this.date);
    }

    /**
     * Get a date that is valid and is in valid deadline format.
     */
    public static String getValidDate(String date) throws IllegalValueException {
        if (DateUtil.isEmptyDate(date)) {
            return date;
        }
        try {
            return DateUtil.parseDate(date);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is in a valid deadline format.
     */
    public static boolean isValidDeadlineFormat(String test) {
        return DateUtil.isEmptyDate(test) || DateUtil.isValidDateFormat(test);
    }

    @Override
    public String getValue() {
        return date;
    }

    @Override
    public String toString() {
        return date;
    }

```
###### /java/seedu/address/model/task/Deadline.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this || (other instanceof Deadline && isSameDeadline((Deadline) other));
    }

    private boolean isSameDeadline(Deadline other) {
        return date.equals(other.date);
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }

}
```
###### /java/seedu/address/model/task/EventDate.java
``` java
/**
 * Represents a Event's dates Guarantees: is valid as declared in
 * {@link #isValidEventDateFormat(String)}
 */
public class EventDate implements Date {

    public static final String MESSAGE_EVENT_DATE_CONSTRAINTS = "Event date must be a valid date";

    private String date;

    private String startDate;
    private String endDate;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException
     *             if given dates string is invalid.
     */
    public EventDate(String startDate, String endDate) throws IllegalValueException {
        assert startDate != null && endDate != null;
        this.startDate = getValidDate(startDate.trim());
        assert isValidEventDateFormat(this.startDate);
        this.endDate = getValidDate(endDate.trim());
        assert isValidEventDateFormat(this.endDate);
        this.date = this.startDate + " to " + this.endDate;
    }

    /**
     * Get a date that is valid and is in a valid event date format.
     */
    public static String getValidDate(String date) throws IllegalValueException {
        try {
            return DateUtil.parseDate(date);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_EVENT_DATE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is in a valid event date format.
     */
    private static boolean isValidEventDateFormat(String test) {
        return DateUtil.isValidDateFormat(test);
    }

    @Override
    public String getValue() {
        return date;
    }

    @Override
    public String toString() {
        return date;
    }

    @Override
    public boolean equals(Object other) {
        return other == this || (other instanceof EventDate && isSameEventDate((EventDate) other));
    }

    private boolean isSameEventDate(EventDate other) {
        return date.equals(other.date);
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDate, endDate);
    }

    public String getStartDate() {
        return startDate;
    }

    public String getEndDate() {
        return endDate;
    }

```
###### /java/seedu/address/model/task/Task.java
``` java
    @Override
    public Date getDate() {
        return date;
    }

    @Override
    public boolean isEvent() {
        return isEvent;
    }
```
###### /java/seedu/address/model/task/Task.java
``` java
    public void setName(Name newName) {
        name = newName;
        nameString.set(name.taskName);
    }

    public void setDate(Date newDate) {
        date = newDate;
        dateString.setValue(date.getValue());
        // It does nothing but can magically fix a bug. It seems like the UI
        // need some time to reflect.
        dateString.get();
    }

    public void setRecurring(Recurring newRecurring) {
        recurring = newRecurring;
        isRecurring = true;
        recurringString.set(recurring.recurringFrequency);
    }

    /**
     * Returns Observable wrappers of the task
     */
    public StringProperty getNameString() {
        return nameString;
    }

    public StringProperty getDateString() {
        return dateString;
    }

    public BooleanProperty getDone() {
        return done;
    }

    public StringProperty getRecurringString() {
        return recurringString;
    }

    /*
     * Makes Task observable by its status
     */
    public static Callback<Task, Observable[]> extractor() {
        return (Task task) -> new Observable[] { task.getNameString(), task.getDateString(), task.getDone(),
                task.getRecurringString(), task.getPriorityInteger() };
    }

```
###### /java/seedu/address/model/TaskManager.java
``` java
    public void markTask(ReadOnlyTask p)  {
        p.markAsDone();
    }

```
###### /java/seedu/address/storage/Storage.java
``` java
    /**
     * Saves the current version of the Task Manager to a new file in hard disk.
     *   Delete the old data file if it is specified.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleStoragePathChangedEvent(StoragePathChangedEvent abce);
    
    /**
     * Saves the current version of the Task Manager to the previous file in hard disk.
     *   Delete the new data file if it is specified.
     */
    void handleStoragePathChangedBackEvent(StoragePathChangedBackEvent abce);
    
    /**
     * Redo saves the current version of the Task Manager to the new file in hard disk.
     *   Delete the new data file if it was previously specified.
     */
    void handleRedoStoragePathChangedEvent(RedoStoragePathChangedEvent abce);
}
```
###### /java/seedu/address/storage/StorageManager.java
``` java
    @Override
    public String getTaskManagerPreviousFilePath() {
        return taskManagerStorage.getTaskManagerPreviousFilePath();
    }
    
    
    @Override
    public void setTaskManagerFilePath(String filePath) {
        taskManagerStorage.setTaskManagerFilePath(filePath);
    }
```
###### /java/seedu/address/storage/StorageManager.java
``` java
    @Override
    public void deleteTaskManager() throws IOException {
        deleteTaskManager(taskManagerStorage.getTaskManagerFilePath());
    }
    
    @Override
    public void deleteTaskManager(String filePath) throws IOException {
        logger.fine("Attempting to delete the data file: " + filePath);
        taskManagerStorage.deleteTaskManager(filePath);
    }

    @Override
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveTaskManager(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }
    
    @Override
    @Subscribe
    public void handleStoragePathChangedEvent(StoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Storage file path changed, saving to new file"));
        try {
            if (event.isToClearOld) {
                deleteTaskManager(getTaskManagerFilePath());
            }
            setTaskManagerFilePath(event.newStorageFilePath);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }
    
    @Override
    @Subscribe
    public void handleStoragePathChangedBackEvent(StoragePathChangedBackEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Storage file path changed back"));
        EventsCenter.getInstance().post(new StoragePathChangedEvent(getTaskManagerPreviousFilePath(), event.isToClearNew));
    }
    
    @Override
    @Subscribe
    public void handleRedoStoragePathChangedEvent(RedoStoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Redo storage file path changed"));
        EventsCenter.getInstance().post(new StoragePathChangedEvent(getTaskManagerPreviousFilePath(), event.isToClearOld));
    }

}
```
###### /java/seedu/address/storage/TaskManagerStorage.java
``` java
    /**
     * Delete the storage file.
     * @throws IOException if there was any problem deleting the file.
     */
    void deleteTaskManager() throws IOException;
    
    void deleteTaskManager(String filePath) throws IOException;

}
```
###### /java/seedu/address/storage/XmlFileStorage.java
``` java
    /**
     * Delete the XML storage file with the specified path.
     */
    public static void deleteFile(Path filePath) throws IOException{
        Files.deleteIfExists(filePath);
    }
```
###### /java/seedu/address/storage/XmlTaskManagerStorage.java
``` java
    @Override
    public void deleteTaskManager() throws IOException {
        deleteTaskManager(filePath);
    }
```
